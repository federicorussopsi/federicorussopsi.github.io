<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elastic Key Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: black;
        }
        canvas {
            position: absolute;
        }
        #gif {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <img id="gif" src="https://www.icegif.com/wp-content/uploads/2023/01/icegif-162.gif" />
    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Serratura a destra senza il riquadro
        const keyhole = { x: canvas.width - 150, y: canvas.height / 2, width: 100, height: 160 };  // Serratura spostata a destra senza riquadro
        
        class Key {
            constructor(x, y, label) {
                this.x = x;
                this.y = y;
                this.label = label;
                this.radius = 30;
                this.isDragging = false;
                this.startX = x;
                this.startY = y;
                this.elasticForce = { x: 0, y: 0 };
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = "gold";
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = "black";
                ctx.font = "40px Arial"; // Maggiore dimensione per l'emoji ðŸ”‘
                ctx.textAlign = "center";
                ctx.fillText("ðŸ”‘", this.x, this.y + 15);  // Emoji ðŸ”‘ al posto della parola
            }
        }

        const keys = [
            new Key(canvas.width / 2, canvas.height / 2 - 100, "START") // Mantenuto solo un pulsante
        ];

        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Disegna l'emoji ðŸšª al posto del riquadro della serratura, con dimensioni piÃ¹ grandi
            ctx.font = "120px Arial";  // Dimensioni maggiori per l'emoji ðŸšª
            ctx.textAlign = "center";
            ctx.fillText("ðŸšª", keyhole.x + keyhole.width / 2, keyhole.y);  // Emoji nella serratura senza riquadro
            
            keys.forEach(key => key.draw());
        }

        canvas.addEventListener("mousedown", (e) => {
            const { clientX, clientY } = e;
            keys.forEach(key => {
                const dist = Math.hypot(clientX - key.x, clientY - key.y);
                if (dist < key.radius) {
                    key.isDragging = true;
                }
            });
        });

        canvas.addEventListener("mousemove", (e) => {
            keys.forEach(key => {
                if (key.isDragging) {
                    key.x = e.clientX;
                    key.y = e.clientY;
                }
            });
        });

        canvas.addEventListener("mouseup", () => {
            keys.forEach(key => {
                if (key.isDragging) {
                    key.isDragging = false;
                    key.elasticForce.x = (key.startX - key.x) * 2;
                    key.elasticForce.y = (key.startY - key.y) * 2;
                    key.x += key.elasticForce.x;
                    key.y += key.elasticForce.y;

                    // Check for win condition
                    if (
                        key.x > keyhole.x &&
                        key.x < keyhole.x + keyhole.width &&
                        key.y > keyhole.y - keyhole.height / 2 &&
                        key.y < keyhole.y + keyhole.height / 2
                    ) {
                        animateKeyIntoKeyhole(key); // Avvia l'animazione per la chiave
                    } else {
                        resetKey(key);  // Torna alla posizione iniziale
                    }
                }
            });
        });

        function resetKey(key) {
            const interval = setInterval(() => {
                const dx = key.startX - key.x;
                const dy = key.startY - key.y;
                const distance = Math.hypot(dx, dy);
                
                if (distance > 2) {
                    key.x += dx / distance * 5;  // VelocitÃ  del ritorno alla posizione iniziale
                    key.y += dy / distance * 5;
                } else {
                    key.x = key.startX;
                    key.y = key.startY;
                    clearInterval(interval);  // Ferma l'animazione di ritorno
                }

                drawGame();
            }, 16); // Circa 60 fps
        }

        function animateKeyIntoKeyhole(key) {
            // Animazione per far spostare la chiave verso la serratura
            const interval = setInterval(() => {
                const dx = keyhole.x + keyhole.width / 2 - key.x;
                const dy = keyhole.y - key.y;
                const distance = Math.hypot(dx, dy);
                
                if (distance > 2) {
                    key.x += dx / distance * 5;  // VelocitÃ  della chiave verso la serratura
                    key.y += dy / distance * 5;
                } else {
                    key.x = keyhole.x + keyhole.width / 2;
                    key.y = keyhole.y;
                    clearInterval(interval);  // Ferma l'animazione
                    showGif();  // Mostra la gif
                }

                drawGame();
            }, 16); // Circa 60 fps
        }

        function showGif() {
            const gif = document.getElementById("gif");
            gif.style.display = "block"; // Mostra la gif
            setTimeout(() => {
                alert("HAI VINTO"); // Mostra la modale
            }, 1500); // Attende che la gif sia visibile prima di mostrare il messaggio
        }

        function gameLoop() {
            drawGame();
            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>
